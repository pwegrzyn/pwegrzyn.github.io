<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Patryk Wegrzyn</title><link>https://pwegrzyn.github.io/</link><description>Recent content on Patryk Wegrzyn</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 31 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://pwegrzyn.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>On the (Un)reasonable Effectiveness of Math in Physics</title><link>https://pwegrzyn.github.io/posts/on-the-unreasonable-effectiveness-of-math/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/on-the-unreasonable-effectiveness-of-math/</guid><description>In his famous 1960 article Eugene Wigner argued about &amp;ldquo;the unreasonable effectiveness of mathematics in the natural sciences&amp;rdquo;. The main point made here was the existence of a seemingly unexpected natural relationship between math and physics. Specifically, why does math lend itself so well to modelling of physical reality? Why are physical laws and processes even expressible as mathematical equations in the first place? Where does this correspondence between abstract platonic ideas and concrete physical observations originate from?</description></item><item><title>Why Functional Programming is (Still) Relatively Unpopular?</title><link>https://pwegrzyn.github.io/posts/functional-vs-imperative-v2/</link><pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/functional-vs-imperative-v2/</guid><description>Some time ago I wrote a post arguing why every developer should know both functional and imperative programming. My position on this matter hasn&amp;rsquo;t fundamentally changed since then, but I do have spend some more time thinking about it. If both approaches are equally valid and, according to some, FP even has more advantages, why is it that there are still way less functional programmers? Let&amp;rsquo;s explore this further in this post.</description></item><item><title>Geometry is Everywhere: or How I Learned to Stop Worrying and Love the Manifold</title><link>https://pwegrzyn.github.io/posts/differential-geometry-is-everywhere/</link><pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/differential-geometry-is-everywhere/</guid><description>When I was in high school, I was really into physics. Later, even though I chose to purse a degree in Computer Science, my love for physics did not go away. Quite the opposite, my math classes at uni allowed me to finally go deeper into more advanced physics topics (till then I had really only read the first tomes of Feynman&amp;rsquo;s lecture textbooks, GR and QM was beyond my skills at that period).</description></item><item><title>The ETC Principle</title><link>https://pwegrzyn.github.io/posts/the-etc-principle/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/the-etc-principle/</guid><description>There&amp;rsquo;s quite a few popular software engineering principles (often remembered in the form of catchy acronyms):
S.O.L.I.D. Single responsibility: A component should have a single reason to change. Open-closed: A component should be easily extendable without much need for modification. Liskov substitution: A derived class should be easily swappable with it&amp;rsquo;s base class. Interface segregation: Write concise interface definitions with a single purpose. Dependency inversion: High-level components should not depend on low-level components, low-level components should instead depend on interfaces defined by high-level components.</description></item><item><title>Loss Landscapes, Mode Connectivity and Generalization in Deep Neural Nets</title><link>https://pwegrzyn.github.io/posts/mode-connectivity/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/mode-connectivity/</guid><description>The impact of deep learning on the fields of computer science, artificial intelligence and many others cannot be understated. Some even go as far as to say that this type of automated reasoning based on data and not on explicit rules will spark a new era of software [1]. However, despite the tremendous success of deep neural nets, their remarkablew effectivness and good generalization capabilites are not yet fully understood. Over the last couple of months I decided to dig a bit deeper into the fundamental aspects of deep learning such as network architecture, depth, width, optimizer method, loss surface and others, to try to develop an intuition on what makes some models great and others mediocre.</description></item><item><title>My New Favourite Math Abstraction - Lawvere's Fixed Point Theorem</title><link>https://pwegrzyn.github.io/posts/my-new-favourite-math-theorem/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/my-new-favourite-math-theorem/</guid><description>When someone&amp;rsquo;s asked to think about the most famous and revolutionary math ideas in recent centuries, there&amp;rsquo;s a high probability that they will think of either Cantor&amp;rsquo;s diagonal argument, proving that some infinities are bigger than others, or GÃ¶del&amp;rsquo;s incompleteness theorem, which shows that a formal system can contain statements that are not provable within the system, or Russell&amp;rsquo;s paradox, which suggests that some sets are actually not allowed to exist, or Turing&amp;rsquo;s halting problem, which in essence proves that not all problems have an algorithmic solution.</description></item><item><title>The Case Against "Against Crypto"</title><link>https://pwegrzyn.github.io/posts/the-case-against-against-crypto/</link><pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/the-case-against-against-crypto/</guid><description>Over the recent months I&amp;rsquo;ve come across a lot of negative comments aimed at the entire Crypto space, blaming Bitcoin (and other projects) for seemingly all the evil that&amp;rsquo;s been present in the news: ransomware attacks rate increases, global warming, retail investor scams, etc. The general impression one could get after being presented with such allegations is that Blockchain is simply a useless waste of energy at best and dangerous criminal activity accelerator at worst.</description></item><item><title>The Single Most Valuable Math Book You Probably Haven't Heard About</title><link>https://pwegrzyn.github.io/posts/thinking-mathematically-review/</link><pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/thinking-mathematically-review/</guid><description>Recently, I&amp;rsquo;ve had the pleasure of reading &amp;ldquo;Thinking mathematically&amp;rdquo; by J. Mason, L. Burton and K. Stacey. The book has been recommended to me in a random Twitter conversation and since I haven&amp;rsquo;t really heard about it before (nor had I any familiarity with its authors) I decided to push in on top of my reading list out of sheer curiosity regarding its praising reviews. And oh boy, was I not disappointed!</description></item><item><title>Why Every Developer Should Know Both Structural and Functional Programming</title><link>https://pwegrzyn.github.io/posts/why-learn-functional-and-imperative/</link><pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/why-learn-functional-and-imperative/</guid><description>The apparent feud between functional and imperative (OOP/structural) programmers have been with us since the very inception of this industry. Usually, developers tend to identify as either a strong believer of one or the other. In my opinion, a competent programmer should be familiar with both and know when to use one over the other, based on their strenghts and weaknesses. One is not inherently better than the other, each has characteristics making it better suited for some tasks and less optimal in others.</description></item><item><title>Getting Started with OpenGL in 2020</title><link>https://pwegrzyn.github.io/posts/getting-started-with-opengl/</link><pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/getting-started-with-opengl/</guid><description>Picking up game development is pretty straightforward nowadays. You can just use one of the many beginner-friendly libraries/game-engines available in popular languages - for Python that would be for example PyGame, for Java - FXGL and for JS - GDevelop. Or, if you want to dive straight into more serious stuff, you could just go for Unity. However, soon you&amp;rsquo;ll notice that get more control over the graphics rendering pipeline (maybe you want to squeeze every bit of performance of your game or you just wish to implement a cool graphics effect) there&amp;rsquo;s currently still not better choice than picking good ol&amp;rsquo; C++ along with a low-level graphics library.</description></item><item><title>Software Migration Tips (Python 3 Edition)</title><link>https://pwegrzyn.github.io/posts/migration-tips/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/posts/migration-tips/</guid><description>In this post I&amp;rsquo;d like to share some tips in regard to migrating a fairly complex software system to a new version of the programming language in which it has been originally written in. Most of the advice will be based on and related to the migration from Python 2 to Python 3 as this is probably the most likely migration process you can encounter in your near-future software career and it also happens to be the process I have the most experience with.</description></item><item><title>About</title><link>https://pwegrzyn.github.io/pages/about/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/pages/about/</guid><description>Hi ð, I&amp;rsquo;m Patryk, a software engineer based in Poland.
I obtained my Bachelor&amp;rsquo;s degree in Computer Science from AGH-UST in Krakow. In first years of my studies I was mainly interested in distributed systems and cryptography, leading to my graduation project being a fully-fledged cryptocurrency implementation from scratch. Later, during my Master&amp;rsquo;s degree, I switched focus to machine learning - in my final thesis I studied the generalization capabilities of deep neural nets through the lens of geometries of loss function manifolds.</description></item></channel></rss>