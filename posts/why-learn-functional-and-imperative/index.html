<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Why Every Developer Should Know Both Structural and Functional Programming | Patryk Wegrzyn</title>
<meta property="og:title" content="Why Every Developer Should Know Both Structural and Functional Programming | Patryk Wegrzyn"><meta name=twitter:title content="Why Every Developer Should Know Both Structural and Functional Programming | Patryk Wegrzyn"><meta itemprop=name content="Why Every Developer Should Know Both Structural and Functional Programming | Patryk Wegrzyn"><meta name=application-name content="Why Every Developer Should Know Both Structural and Functional Programming | Patryk Wegrzyn"><meta property="og:site_name" content="Patryk Wegrzyn"><meta name=description content="Software Engineer ðŸ’»"><meta itemprop=description content="Software Engineer ðŸ’»"><meta property="og:description" content="Software Engineer ðŸ’»"><meta name=twitter:description content="Software Engineer ðŸ’»"><meta property="og:locale" content="en-gb"><meta name=language content="en-gb"><meta itemprop=image content="https://pwegrzyn.github.io"><meta property="og:image" content="https://pwegrzyn.github.io"><meta name=twitter:image content="https://pwegrzyn.github.io"><meta name=twitter:image:src content="https://pwegrzyn.github.io"><meta property="og:type" content="article"><meta property="og:article:published_time" content="2021-06-24T00:00:00Z"><meta property="article:published_time" content="2021-06-24T00:00:00Z"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Why Every Developer Should Know Both Structural and Functional Programming","author":{"@type":"Person","name":""},"datePublished":"2021-06-24","description":"","wordCount":743,"mainEntityOfPage":"True","dateModified":"2021-06-24","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Patryk Wegrzyn"}}</script><meta name=generator content="Hugo 0.122.0"><link rel=canonical href=https://pwegrzyn.github.io/posts/why-learn-functional-and-imperative/><link href=https://pwegrzyn.github.io/style.min.d43bc6c79baa87f006efb2b92be952faeedeb1a3ab626c1d6abda52eae049355.css rel=stylesheet><link href=https://pwegrzyn.github.io/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=https://pwegrzyn.github.io/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://pwegrzyn.github.io/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://pwegrzyn.github.io/icons/favicon-16x16.png><link rel=mask-icon href=https://pwegrzyn.github.io/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=https://pwegrzyn.github.io/favicon.ico><link rel=manifest href=https://pwegrzyn.github.io/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=https://pwegrzyn.github.io/icons/favicon.svg></head><body data-theme=dark class=notransition><script src=https://pwegrzyn.github.io/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://pwegrzyn.github.io/ class=logo><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=https://pwegrzyn.github.io/>Home</a></li><li><a class="menu-link active" href=https://pwegrzyn.github.io/posts/>Posts</a></li><li><a class=menu-link href=https://pwegrzyn.github.io/pages/about/>About</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Why Every Developer Should Know Both Structural and Functional Programming</h1><div class=post-meta><time datetime=2021-06-24T00:00:00+00:00 itemprop=datePublished>24 Jun 2021</time></div></header><details class=toc zgotmplz><summary><b>Table of Contents</b></summary><nav id=TableOfContents><ul><li><a href=#functional-programming>Functional programming</a></li><li><a href=#imperativeobject-orientedstructural-programming>Imperative/Object-oriented/Structural programming</a></li></ul></nav></details><div class=page-content><p>The apparent feud between functional and imperative (OOP/structural) programmers have been with us since the very inception of this industry.
Usually, developers tend to identify as either a strong believer of one or the other. In my opinion, a competent programmer should be familiar with both and know when to use one over the other, based on their strenghts and weaknesses.
One is not inherently better than the other, each has characteristics making it better suited for some tasks and less optimal in others.</p><h2 id=functional-programming>Functional programming</h2><p>In FP you write programs as compositions of pure functions (functions that deterministacally always produce the same output give some input). To achieve this, you must use immutable data structures. Writing in FP style also forces you to
minimize side effects, the main one being of course IO. All these aspects seem great, since they make your program easier to test and better suited for tasks which require concurrency.</p><p>However, each has it&rsquo;s drawback: immutability requires lots of copying or tricky algorithms to update only changing parts of data structures, managment of side effects becomes more complex and on overhead of itself and, finally, not each application can be necessarily easily and naturally written as a function composition.</p><p>In my opinion, the most practical (and beautiful) aspect of FP, comes from the <a href=https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence>Curryâ€“Howard correspondence</a>. Loosely speaking, this theorem states that programs are equal to mathematical proofs. This is especially prominent when your consider the most basic form of functional programming - <a href=https://en.wikipedia.org/wiki/Lambda_calculus>Lambda calculus</a> (LC). In this <a href=https://en.wikipedia.org/wiki/Model_of_computation>model of computation</a> you are only allowed to use 1 primitive - an abstract function object. But can you even program using ONLY functions? Yup, check <a href=https://gist.github.com/pwegrzyn/31c684a7ef32a5cabb3459a9375baaeb>this</a> out.</p><p>Now consider a slightly more advanced version of Lambda calculus, with some nice syntactic sugar - Haskell.
Let&rsquo;s say I want to prove this mathematical theorem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=p>(</span><span class=kt>A</span> <span class=ow>-&gt;</span> <span class=kt>B</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>B</span> <span class=ow>-&gt;</span> <span class=kt>C</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>A</span> <span class=ow>-&gt;</span> <span class=kt>C</span>
</span></span></code></pre></div><p>Looks easy, I know that A implies B and that B implies C, therefore A should imply C. We can translate this logical preposition to Haskell by defining a function which has a matching type signature:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>impl_comp</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>c</span>
</span></span></code></pre></div><p>Now, to effectively prove this preposition, all we need to do is add a definition to this function signature:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>impl_comp</span> <span class=ow>=</span> <span class=nf>\</span><span class=p>(</span><span class=n>f</span><span class=ow>::</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=nf>\</span><span class=p>(</span><span class=n>g</span><span class=ow>::</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=nf>\</span><span class=p>(</span><span class=n>h</span><span class=ow>::</span><span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>g</span> <span class=p>(</span><span class=n>f</span> <span class=n>h</span><span class=p>)</span>
</span></span></code></pre></div><p>And, lo and behold, we have a proof for a mathematical theorem in the form of a Haskell program. Pretty cool, right? This is exactly Curryâ€“Howard correspondence in action.</p><p>So why do I think this is the main selling point of FP? Because it clearly shows that functional programming has an inherent and close connection to logic and math in general. This in turn means that FP is perfect for use cases where the domain and business logic is complex enough to justify using more advanced abstractions and generalizations, and where you also need an almost mathematically-strict way of proving the correctness of your solutions. Compared to imperative programming, FP&rsquo;s lack of
mutability leads to easier work with highly concurrent systems.</p><h2 id=imperativeobject-orientedstructural-programming>Imperative/Object-oriented/Structural programming</h2><p>For most, imperative programming is a more natural way of writing code, and that shouldn&rsquo;t be surpring, thinking in terms of objects and steps then need to be undertaken to transform the state of these objects is closely related to how we view and interact with the world for most of the time. At the same time, we undergo many years of math education to develop a more strict way of reasoning, to deal with more complex concepts which require abstractions and generalizations. You don&rsquo;t calculate the Riemann metric tensor and curvature of spacetime when you want to throw a basketball. By analogy, I&rsquo;d argue that you also shouldn&rsquo;t use advanced FP when writing simple CRUD or CLI applications.</p><p>On another note, imperative programming is much better suited as a base for considerations in the theory of computability, computational complexity and advanced algorithm development, that&rsquo;s because a <a href=https://en.wikipedia.org/wiki/Turing_machine>Turing Machine</a>, which is a mathematical model for all of them, is a sequential and imperative model by it&rsquo;s nature.</p><p>Finally, a sequential and imperative model of computation is much easier to implement in hardware, so when working with low-level code you are forced to use this approach. Moreover, functional programming inherently requires more memory and processing power
compared to imperative styles, so for embedded settings the latter is also a clear winner.</p></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://www.linkedin.com/in/patryk-wegrzyn/ target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://twitter.com/_patrykw target=_blank rel="noopener noreferrer me" title=X><svg viewBox="0 0 1200 1227" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path d="M714.163 519.284 1160.89.0H1055.03L667.137 450.887 357.328.0H0L468.492 681.821.0 1226.37H105.866L515.491 750.218 842.672 1226.37H12e2L714.137 519.284H714.163zM569.165 687.828l-47.468-67.894L144.011 79.6944H306.615L611.412 515.685l47.468 67.894 396.2 566.721H892.476L569.165 687.854V687.828z"/></svg>
</a><a href=https://github.com/pwegrzyn target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div><small class=footer_copyright>Â© 2024 Patryk Wegrzyn.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title="Go to top" id=totop><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg>
</a><script src=https://pwegrzyn.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>