<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>software on Patryk Węgrzyn</title><link>https://pwegrzyn.github.io/categories/software/</link><description>Recent content in software on Patryk Węgrzyn</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 31 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://pwegrzyn.github.io/categories/software/index.xml" rel="self" type="application/rss+xml"/><item><title>Why Functional Programming is (Still) Relatively Unpopular?</title><link>https://pwegrzyn.github.io/2021/functional-vs-imperative-v2/</link><pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/2021/functional-vs-imperative-v2/</guid><description>Some time ago I wrote a post arguing why every developer should know both functional and imperative programming. My position on this matter hasn&amp;rsquo;t fundamentally changed since then, but I do have spend some more time thinking about it. If both approaches are equally valid and, according to some, FP even has more advantages, why is it that there are still way less functional programmers? Let&amp;rsquo;s explore this further in this post.</description></item><item><title>The ETC Principle</title><link>https://pwegrzyn.github.io/2021/the-etc-principle/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/2021/the-etc-principle/</guid><description>There&amp;rsquo;s quite a few popular software engineering principles (often remembered in the form of catchy acronyms):
S.O.L.I.D. Single responsibility: A component should have a single reason to change. Open-closed: A component should be easily extendable without much need for modification. Liskov substitution: A derived class should be easily swappable with it&amp;rsquo;s base class. Interface segregation: Write concise interface definitions with a single purpose. Dependency inversion: High-level components should not depend on low-level components, low-level components should instead depend on interfaces defined by high-level components.</description></item><item><title>Loss Landscapes, Mode Connectivity and Generalization in Deep Neural Nets</title><link>https://pwegrzyn.github.io/2021/mode-connectivity/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/2021/mode-connectivity/</guid><description>The impact of deep learning on the fields of computer science, artificial intelligence and many others cannot be understated. Some even go as far as to say that this type of automated reasoning based on data and not on explicit rules will spark a new era of software [1]. However, despite the tremendous success of deep neural nets, their remarkablew effectivness and good generalization capabilites are not yet fully understood. Over the last couple of months I decided to dig a bit deeper into the fundamental aspects of deep learning such as network architecture, depth, width, optimizer method, loss surface and others, to try to develop an intuition on what makes some models great and others mediocre.</description></item><item><title>Why Every Developer Should Know Both Structural and Functional Programming</title><link>https://pwegrzyn.github.io/2021/why-learn-functional-and-imperative/</link><pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/2021/why-learn-functional-and-imperative/</guid><description>The apparent feud between functional and imperative (OOP/structural) programmers have been with us since the very inception of this industry. Usually, developers tend to identify as either a strong believer of one or the other. In my opinion, a competent programmer should be familiar with both and know when to use one over the other, based on their strenghts and weaknesses. One is not inherently better than the other, each has characteristics making it better suited for some tasks and less optimal in others.</description></item><item><title>Software Migration Tips (Python 3 Edition)</title><link>https://pwegrzyn.github.io/2020/migration-tips/</link><pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate><guid>https://pwegrzyn.github.io/2020/migration-tips/</guid><description>In this post I&amp;rsquo;d like to share some tips in regard to migrating a fairly complex software system to a new version of the programming language in which it has been originally written in. Most of the advice will be based on and related to the migration from Python 2 to Python 3 as this is probably the most likely migration process you can encounter in your near-future software career and it also happens to be the process I have the most experience with.</description></item></channel></rss>