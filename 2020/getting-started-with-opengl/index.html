<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="chrome=1">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<link rel=prev href=https://pwegrzyn.github.io/2020/migration-tips/>
<link rel=next href=https://pwegrzyn.github.io/2021/why-learn-functional-and-imperative/>
<link rel=canonical href=https://pwegrzyn.github.io/2020/getting-started-with-opengl/>
<link rel="shortcut icon" type=image/x-icon href=https://pwegrzyn.github.io/favicon.ico>
<link rel=apple-touch-icon sizes=180x180 href=https://pwegrzyn.github.io/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=https://pwegrzyn.github.io/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=https://pwegrzyn.github.io/favicon-16x16.png>
<link rel=manifest href=https://pwegrzyn.github.io/site.webmanifest>
<link rel=mask-icon href=https://pwegrzyn.github.io/safari-pinned-tab.svg color=#5bbad5>
<meta name=msapplication-TileColor content="#da532c">
<meta name=theme-color content="#ffffff">
<title>
Getting Started with OpenGL in 2020 | Patryk Węgrzyn | Software Engineer
</title>
<meta name=title content="Getting Started with OpenGL in 2020 | Patryk Węgrzyn | Software Engineer">
<link rel=stylesheet href=https://pwegrzyn.github.io/font/iconfont.css>
<link rel=stylesheet href=https://pwegrzyn.github.io/css/main.min.css>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Getting Started with OpenGL in 2020">
<meta name=twitter:description content="Picking up game development is pretty straightforward nowadays. You can just use one of the many beginner-friendly libraries/game-engines available in popular languages - for Python that would be for example PyGame, for Java - FXGL and for JS - GDevelop. Or, if you want to dive straight into more serious stuff, you could just go for Unity. However, soon you&rsquo;ll notice that get more control over the graphics rendering pipeline (maybe you want to squeeze every bit of performance of your game or you just wish to implement a cool graphics effect) there&rsquo;s currently still not better choice than picking good ol' C++ along with a low-level graphics library.">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Getting Started with OpenGL in 2020","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/pwegrzyn.github.io\/2020\/getting-started-with-opengl\/"},"genre":"posts","wordcount":1290,"url":"https:\/\/pwegrzyn.github.io\/2020\/getting-started-with-opengl\/","datePublished":"2020-10-06T00:00:00\u002b00:00","dateModified":"2020-10-06T00:00:00\u002b00:00","publisher":{"@type":"Organization","name":"pwegrzyn","logo":{"@type":"ImageObject","url":"https:\/\/pwegrzyn.github.io\/images\/profile.png","width":127,"height":40}},"author":{"@type":"Person","name":"pwegrzyn"},"description":""}</script>
</head>
<body>
<div class=wrapper>
<nav class=navbar>
<div class=container>
<div class="navbar-header header-logo">
<a href=https://pwegrzyn.github.io>Patryk Węgrzyn | Software Engineer</a>
</div>
<div class="menu navbar-right">
<a class=menu-item href=https://pwegrzyn.github.io/posts/ title>Blog</a>
<a class=menu-item href=https://pwegrzyn.github.io/about title>About</a>
<a href=javascript:void(0); class=theme-switch><i class="iconfont icon-sun"></i></a>&nbsp;
</div>
</div>
</nav>
<nav class=navbar-mobile id=nav-mobile style=display:none>
<div class=container>
<div class=navbar-header>
<div> <a href=javascript:void(0); class=theme-switch><i class="iconfont icon-sun"></i></a>&nbsp;<a href=https://pwegrzyn.github.io>Patryk Węgrzyn | Software Engineer</a></div>
<div class=menu-toggle>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=mobile-menu>
<a class=menu-item href=https://pwegrzyn.github.io/posts/ title>Blog</a>
<a class=menu-item href=https://pwegrzyn.github.io/about title>About</a>
</div>
</div>
</nav>
<main class=main>
<div class=container>
<article class=post-warp>
<header class=post-header>
<h1 class=post-title>Getting Started with OpenGL in 2020</h1>
<div class=post-meta>
Written by <a href=https://pwegrzyn.github.io rel=author>Patryk Węgrzyn</a> with ♥
<span class=post-time>
on <time datetime=2020-10-06>6 October 2020</time>
</span>
in
<i class="iconfont icon-folder"></i>
<span class=post-category>
<a href=https://pwegrzyn.github.io/categories/cpp/> cpp </a>
<a href=https://pwegrzyn.github.io/categories/graphics/> graphics </a>
<a href=https://pwegrzyn.github.io/categories/opengl/> opengl </a>
</span>
<i class="iconfont icon-timer"></i>
7 min
</div>
</header>
<div class=post-content>
<p>Picking up game development is pretty straightforward nowadays. You can just use one of the many beginner-friendly libraries/game-engines available in popular languages - for Python that would be
for example <a href=https://www.pygame.org/news>PyGame</a>, for Java - <a href=https://github.com/AlmasB/FXGL>FXGL</a> and for JS - <a href=https://gdevelop-app.com/>GDevelop</a>. Or, if you want to dive straight into
more serious stuff, you could just go for <a href=https://unity.com/>Unity</a>. However, soon you&rsquo;ll notice that get more control over the graphics rendering pipeline (maybe you want to
squeeze every bit of performance of your game or you just wish to implement a cool graphics effect) there&rsquo;s currently still not better choice than picking good ol' C++ along with a low-level graphics library.</p>
<h2 id=contemporary-real-time-rendering-landscape>Contemporary real-time rendering landscape</h2>
<p>For a long time, rendering libraries were usually closely tied to the hardware that they were originally desinged to be run on. For example, if you wish to develop games on Windows you should definitely choose DirectX (or more
specifically - Direct3D). If you want to ship a game on Macs - go for Metal. Lately, a truly cross-platform API has been steadily been gaining more and more traction - Vulkan by Khronos. It&rsquo;s a really powerful, low-levelk framework
that promises to allow developing graphics-heavy apps on Windows, Mac and Linux. However, it has a considerable drawback from our perspective - it&rsquo;s not really beginner-friendly. Drawing a simple triangle on the screen would probably
require at least 500 lines of C++ and getting through hours of documentation and/or tutorials.</p>
<p>But fear not - there&rsquo;s one more cross-platform, powerful and respected graphics API - OpenGL. Yes, it&rsquo;s pretty old (30 years or so) and some of the design decisions made by the creators are questionable to say the least. But neverthless, it&rsquo;s still a very mature,
capable and more importantly - relatively easy to get started graphics rendering framework. Although the specification itself is pretty straightforward and simple - getting a running development setup might be a bit more tricky. That&rsquo;s what we&rsquo;ll cover next.</p>
<h2 id=intro-to-opengl>Intro to OpenGL</h2>
<p>First things first - OpenGL is not a library (nor a game engine), it&rsquo;s just an API specification - it&rsquo;s up to your hardware GPU mancufacturer to deliver their own implementation of the spec. If you use for example a NVIDIA card with up-to-date drivers, they will
most likely come with an full OpenGL implementation. On one hand this seems nice, becase we don&rsquo;t have to install the library manually, on the other hand - you will not have access to the source code, since it&rsquo;s proprietary (but then again, going through low-leve C code is not something most people would classify as enjoyable way of spending time). So, OpenGL itself will take care of that. Next, we need a way to create windows and handle interactions with them. This part is very OS-specific by it&rsquo;s nature. Technically, you would want to
just use your OS' API to handle all this stuff, but this approach is quite tedious and not portable. For a simple project a better way would be to use an existing windowing library. One of the best and easy-to-use in my opinion is <a href=https://www.glfw.org/>GLFW</a>. It&rsquo;s specifically desinged to work with OpenGL (and also OpenGL ES and Vulkan) and comes with support for Windows and Unix-like systems out of the box. So, just download the pre-compiled binaries for your OS and setup up static-linking in your IDE (many guids how to do that).</p>
<p>After that, you should be able to compile a simple program which creats a window within which you can later start rendering stuff. However, it will probably not link correctly. In order for it to link, you will need to include the <code>openGL32.lib</code> library in you linker dependencies. After doing so, it should work, but you&rsquo;ll quickly notice that the declarations of OpenGL functions are a bit weird. That&rsquo;s because we used the native Windows headers for OpenGL and they are not really up-to-date with modern OpenGL versions.</p>
<p>In order the you utilize the header declarations of more modern OpenGL functions we will use a library called <a href=http://glew.sourceforge.net/>glew</a>. It&rsquo;s job is to determine at run-time which extensions are available on your hardware, provide you with modern OpenGL declarations and finally do some magic behind-the-scenes to fetch the function pointers to the actual code delivered by your GPU manufacturer and map it the the aforementioned declarations. Getting started with using it might be a bit tricky so I&rsquo;d advise you to just
follow the instructions on their page, since they are very informative and up-to-date.</p>
<p>Finally, after following all the steps above, you&rsquo;re ready to start writing OpenGL code.</p>
<h2 id=opengl-api-data-abstractions-in-a-nutshell>OpenGL API data abstractions in a nutshell</h2>
<p>OpenGL&rsquo;s API, like many other graphics rendering APIs, follows a clear structure. In a typical rendering application you will have two major subsets of components - one for handling data and the other for handling the computations done on that data.
The main concept within the former group are <em>Vertex Buffer</em>. Think of those basically as smart data-arrays that automatically handle the process of pushing data into the GPU. VertexBuffer by itself are useless though, we first need a way to tell OpenGL
what is the structure of the data we put into the buffers. That&rsquo;s where <em>Vertex Attributes</em> come into play. They allow you to programatically specify what is the layout of the data and how should the GPU interpret it, byte-by-byte. <em>Vertex Attribute Pointers</em> are used
to bind attributes to buffers. In order to make the process more structured and manageable, OpenGL comes with what&rsquo;s known as <em>Vertex Arrays</em>. Technically, you could skip them entirely, and just a single, global, implicit array and do all the bindings why yourself, but
this quickly could become cumbersome, so the general advice is to use Vertex Arrays. The last major element of the data-focus-components are <em>Vertex Index Buffers</em>. They are used to re-use parts of the data you specified inside vertex buffers - specifically, instead of creating a huuge vertex buffer with the data for all the vertices of a complex 3D model you can just create a much simpler vertex buffer with only the main vertices and then later re-use the data associated with them via indices stored in index buffers.</p>
<h2 id=opengl-processing-birds-eye-view>OpenGL processing birds-eye view</h2>
<p>That&rsquo;s the data-part of OpenGL, now let&rsquo;s swtich context a little bit and cover the other part of the pipeline - computations. You have all the data you want transfered beautifully to the GPU via vertex buffers, but how do you actually apply tranformations to the data (projections, texturing, lightning, etc.)? That&rsquo;s where <em>shaders</em> come into play. A <em>shader</em> is basically a separate sub-program within you application that is compiled and the run directly on the GPU. The two main categories of shaders we should be concerned for now are <em>vertex shaders</em> and <em>fragment shaders</em>. A typical rendering pipeline initiated by a draw call looks like this: the vertex shader is called for all vertices within you vertex buffer, and then the fragment shaders is called for all pixels that need to be displayed. Shaders are written in a DSL called OpenSL - it&rsquo;s a bit similar to C, but has some major differences that allow it to fit nicely within the aforementioned GPU processing pipeline. The are two major ways of passing data into shaders - uniforms and data specified within vertex buffers. The
latter has already been covered, and the former - uniforms - are quite simple in nature, think of them as global variables avaiable within the context of both the CPU and GPU.</p>
<p>There are maaaany more interesting topics in OpenGL (textures, geometry shaders, all the maths behind projections, etc.) but I&rsquo;ll leave them for another post, since this was supposed to be a quick conceptual introduction :)</p>
<p>Thanks for reading!</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span>Author:</span>
<span>Patryk Węgrzyn </span>
</p>
<p class=copyright-item>
<span>Words:</span>
<span>1290</span>
</p>
<p class=copyright-item>
<span>Share:</span>
<span>
<a href="//twitter.com/share?url=https%3a%2f%2fpwegrzyn.github.io%2f2020%2fgetting-started-with-opengl%2f&text=Getting%20Started%20with%20OpenGL%20in%202020&via=_pwegrzyn" target=_blank title="Share on Twitter">
<i class="iconfont icon-twitter"></i>
</a>
<a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fpwegrzyn.github.io%2f2020%2fgetting-started-with-opengl%2f" target=_blank title="Share on Facebook">
<i class="iconfont icon-facebook"></i>
</a>
<a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fpwegrzyn.github.io%2f2020%2fgetting-started-with-opengl%2f&title=Getting%20Started%20with%20OpenGL%20in%202020" target=_blank title="Share on LinkedIn">
<i class="iconfont icon-linkedin"></i>
</a>
</span>
</p>
<p class=copyright-item>
Released under <a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a>
</p>
</div>
<div class=post-tags>
<section>
<a href=javascript:window.history.back();>Back</a></span> ·
<span><a href=https://pwegrzyn.github.io>Home</a></span>
</section>
</div>
<div class=post-nav>
<a href=https://pwegrzyn.github.io/2020/migration-tips/ class=prev rel=prev title="Software Migration Tips (Python 3 Edition)"><i class="iconfont icon-dajiantou"></i>&nbsp;Software Migration Tips (Python 3 Edition)</a>
<a href=https://pwegrzyn.github.io/2021/why-learn-functional-and-imperative/ class=next rel=next title="Why Every Developer Should Know Both Structural and Functional Programming">Why Every Developer Should Know Both Structural and Functional Programming&nbsp;<i class="iconfont icon-xiaojiantou"></i></a>
</div>
<div class=post-comment>
</div>
</article>
</div>
</main>
<footer class=footer>
<div class=copyright>
&copy;
<span itemprop=copyrightYear>2020 – 2022</span>
<span class=author itemprop=copyrightHolder><a href=https://pwegrzyn.github.io>Patryk Węgrzyn</a></span>
<span></span>
</div>
</footer>
<script src=https://pwegrzyn.github.io/js/vendor_no_gallery.min.js async></script>
</div>
</body>
</html>